use std::collections::HashMap;
use bevy::prelude::*;
use bevy::time::Fixed;
use bevy_rapier3d::prelude::*;
use bevy_renet::renet::{ClientId, RenetServer};
use bevy_renet::{NetcodeServerPlugin, RenetServerPlugin};
use bevy_renet::renet::transport::NetcodeServerTransport;

#[path = "../net.rs"]
mod net;
use crate::net::*;

#[derive(Resource, Default)]
struct Players {
    states: HashMap<u64, PlayerState>,
}

#[derive(Default, Clone, Copy)]
struct PlayerState {
    pos: Vec3,
    yaw: f32,
    hp: u16,
    alive: bool,
}

#[derive(Resource, Default)]
struct LastInputs(HashMap<u64, InputFrame>);

#[derive(Resource, Default)]
struct LastFireSeq(HashMap<u64, u32>);

#[derive(Resource, Default)]
struct RespawnTimers(HashMap<u64, f32>);

fn main() {
    App::new()
        .add_plugins((MinimalPlugins, TimePlugin))
        .add_plugins((RenetServerPlugin, NetcodeServerPlugin))
        .insert_resource(RapierConfiguration::default())
        .insert_resource(Players::default())
        .insert_resource(LastInputs::default())
        .insert_resource(LastFireSeq::default())
        .insert_resource(RespawnTimers::default())
        .insert_resource(Time::<Fixed>::from_hz(60.0))
        .insert_resource(SnapshotTimer(Timer::from_hz(30.0)))
        .add_systems(Startup, setup_server)
        .add_systems(Update, accept_clients)
        .add_systems(FixedUpdate, (recv_inputs, sim_players, broadcast_snapshots))
        .run();
}

fn setup_server(mut commands: Commands) {
    let (server, transport) = new_server();
    commands.insert_resource(server);
    commands.insert_resource(transport);
    info!("Server listening on 0.0.0.0:{}", SERVER_PORT);
}

fn accept_clients(mut server: ResMut<RenetServer>, mut players: ResMut<Players>) {
    while let Some(event) = server.get_event() {
        match event {
            bevy_renet::renet::ServerEvent::ClientConnected { client_id } => {
                let id = client_id.raw();
                players.states.insert(id, PlayerState { pos: Vec3::new(0.0, 1.6, 5.0), yaw: 0.0, hp: 100, alive: true });
                // broadcast spawn
                let ev = ServerMessage::Event(EventMsg::Spawn { id, pos: [0.0, 1.6, 5.0] });
                let bytes = bincode::serialize(&ev).unwrap();
                for cid in server.clients_id() { let _ = server.send_message(*cid, CH_RELIABLE, bytes.clone()); }
                info!("client connected: {}", id);
            }
            bevy_renet::renet::ServerEvent::ClientDisconnected { client_id, reason } => {
                let id = client_id.raw();
                players.states.remove(&id);
                let ev = ServerMessage::Event(EventMsg::Despawn { id });
                let bytes = bincode::serialize(&ev).unwrap();
                for cid in server.clients_id() { let _ = server.send_message(*cid, CH_RELIABLE, bytes.clone()); }
                info!("client disconnected: {} ({:?})", id, reason);
            }
        }
    }
}

fn recv_inputs(mut server: ResMut<RenetServer>, mut last: ResMut<LastInputs>) {
    for client_id in server.clients_id().iter().copied().collect::<Vec<ClientId>>() {
        while let Some(raw) = server.receive_message(client_id, CH_INPUT) {
            if let Ok(msg) = bincode::deserialize::<ClientMessage>(&raw) {
                if let ClientMessage::Input(frame) = msg {
                    last.0.insert(client_id.raw(), frame);
                }
            }
        }
    }
}

fn sim_players(
    time_fixed: Res<Time<Fixed>>,
    mut players: ResMut<Players>,
    last: Res<LastInputs>,
    mut last_fire: ResMut<LastFireSeq>,
    mut respawns: ResMut<RespawnTimers>,
    mut server: ResMut<RenetServer>,
) {
    let dt = time_fixed.delta_seconds();
    for (id, state) in players.states.iter_mut() {
        if let Some(inp) = last.0.get(id) {
            let mut dir = Vec3::new(inp.mv[0], 0.0, inp.mv[1]);
            if dir.length_squared() > 1e-6 {
                dir = dir.normalize();
                let speed = if inp.run { 6.0 * 1.7 } else { 6.0 };
                let yaw_rot = Quat::from_rotation_y(inp.yaw);
                state.pos += yaw_rot * dir * speed * dt;
            }
            state.yaw = inp.yaw;

            // fire edge-trigger
            let last_seq = last_fire.0.entry(*id).or_insert(0);
            if inp.fire && inp.seq != *last_seq && state.alive {
                *last_seq = inp.seq;
                let yaw_rot = Quat::from_rotation_y(inp.yaw);
                let pitch_rot = Quat::from_rotation_x(inp.pitch);
                let forward = yaw_rot * pitch_rot * Vec3::NEG_Z;
                let origin = state.pos + Vec3::new(0.0, 0.7, 0.0);
                let range = 100.0f32;

                let mut best: Option<(u64, f32)> = None;
                for (oid, other) in players.states.iter() {
                    if oid == id || !other.alive { continue; }
                    let target = other.pos + Vec3::new(0.0, 0.7, 0.0);
                    let t = (target - origin).dot(forward).clamp(0.0, range);
                    let closest = origin + forward * t;
                    let dist2 = (target - closest).length_squared();
                    let radius = 0.35f32;
                    if dist2 <= radius * radius {
                        if best.map_or(true, |(_, bt)| t < bt) { best = Some((*oid, t)); }
                    }
                }
                if let Some((hit_id, _)) = best {
                    if let Some(hit) = players.states.get_mut(&hit_id) {
                        if hit.alive {
                            let dmg = 35u16;
                            hit.hp = hit.hp.saturating_sub(dmg);
                            let ev = ServerMessage::Event(EventMsg::Hit { target_id: hit_id, new_hp: hit.hp, by: *id });
                            let bytes = bincode::serialize(&ev).unwrap();
                            for cid in server.clients_id() { let _ = server.send_message(*cid, CH_RELIABLE, bytes.clone()); }
                            if hit.hp == 0 {
                                hit.alive = false;
                                let ev = ServerMessage::Event(EventMsg::Death { target_id: hit_id, by: *id });
                                let bytes = bincode::serialize(&ev).unwrap();
                                for cid in server.clients_id() { let _ = server.send_message(*cid, CH_RELIABLE, bytes.clone()); }
                                respawns.0.insert(hit_id, 2.0);
                            }
                        }
                    }
                }
            }
        }
    }

    // Respawn countdown
    let mut to_spawn = Vec::new();
    for (pid, t) in respawns.0.iter_mut() {
        *t -= dt;
        if *t <= 0.0 { to_spawn.push(*pid); }
    }
    for pid in to_spawn {
        respawns.0.remove(&pid);
        if let Some(p) = players.states.get_mut(&pid) {
            p.alive = true;
            p.hp = 100;
            p.pos = Vec3::new(0.0, 1.6, 5.0);
            let ev = ServerMessage::Event(EventMsg::Spawn { id: pid, pos: [p.pos.x, p.pos.y, p.pos.z] });
            let bytes = bincode::serialize(&ev).unwrap();
            for cid in server.clients_id() { let _ = server.send_message(*cid, CH_RELIABLE, bytes.clone()); }
        }
    }
}

#[derive(Resource)]
struct SnapshotTimer(Timer);

fn broadcast_snapshots(
    time_fixed: Res<Time<Fixed>>,
    mut timer: ResMut<SnapshotTimer>,
    mut server: ResMut<RenetServer>,
    players: Res<Players>,
) {
    timer.0.tick(time_fixed.delta());
    if !timer.0.finished() { return; }
    let snap = SnapshotMsg {
        tick: 0,
        players: players.states.iter().map(|(id, s)| PlayerStateMsg { id: *id, pos: [s.pos.x, s.pos.y, s.pos.z], yaw: s.yaw, alive: s.alive, hp: s.hp }).collect(),
    };
    let bytes = bincode::serialize(&ServerMessage::Snapshot(snap)).unwrap();
    for client_id in server.clients_id() {
        let _ = server.send_message(*client_id, CH_SNAPSHOT, bytes.clone());
    }
}
